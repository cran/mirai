---
title: "mirai - Databases and Arrow"
vignette: >
  %\VignetteIndexEntry{mirai - Databases and Arrow}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

### Database Hosting - The Basics

`mirai` supports the hosting of multiple database connections across processes on the local machine or a remote server. `everywhere()` easily sets up identical database connections in each daemon process.

The following represents a simple example, which sets up 2 local daemons, and then opens a connection to the same SQLite file database in each daemon.

```{r db1}
file <- tempfile()
library(mirai)

daemons(2)

everywhere({
  library(DBI)
  con <<- dbConnect(RSQLite::SQLite(), file)
}, file = file)

```

`mirai()` calls may then be used to write to or query the database, and may be executed on either daemon.

```{r db2}
m <- mirai(dbWriteTable(con, "iris", iris))
call_mirai(m)$data

m <- mirai(dbListTables(con))
call_mirai(m)$data

m <- mirai(dbGetQuery(con, 'SELECT * FROM iris WHERE "Sepal.Length" < 4.6'))
call_mirai(m)$data
```

`everywhere()` can be used again to cleanly tear down the databases, before resetting daemons.
```{r db3}
everywhere(dbDisconnect(con))
daemons(0)
```

### Database Hosting - Using Arrow Database Connectivity

It is possible using the `DBI` interface to access and manipulate data in the Apache Arrow data format efficiently through ABDC (Arrow Database Connectivity).

The example below creates an in-memory SQLite connection using the `adbcsqlite` backend.

Serialization is set up with the relevant serialization and deserialization functions from the `arrow` package. Note that the format class is 'nanoarrow_array_stream' as `nanoarrow` is the backend for all queries made by the DBI `db*Arrow()` functions.

```{r arrow1}
library(mirai)

daemons(1)

everywhere({
  library(DBI) # `adbi` and `adbcsqlite` packages must also be installed
  con <<- dbConnect(adbi::adbi("adbcsqlite"), uri = ":memory:")
})

serialization(
  refhook = list(arrow::write_to_raw,
                 function(x) arrow::read_ipc_stream(x, as_data_frame = FALSE)),
  class = "nanoarrow_array_stream"
)

```

`mirai()` calls may then be used to write to or query the database all in the Arrow format.

```{r arrow2}
m <- mirai(dbWriteTableArrow(con, "iris", iris))
call_mirai(m)$data

m <- mirai(dbReadTableArrow(con, "iris"))
call_mirai(m)$data

m <- mirai(dbGetQueryArrow(con, 'SELECT * FROM iris WHERE "Sepal.Length" < 4.6'))
call_mirai(m)$data
```

Due to the tight integration of the `mirai` serialization mechanism with R's 'refhook' system, we can easily return complex / nested objects containing multiple queries in the Arrow format:

```{r arrow3}
m <- mirai({
  a <- dbGetQueryArrow(con, 'SELECT * FROM iris WHERE "Sepal.Length" < 4.6')
  b <- dbGetQueryArrow(con, 'SELECT * FROM iris WHERE "Sepal.Width" < 2.6')
  x <- dbGetQueryArrow(con, 'SELECT * FROM iris WHERE "Petal.Length" < 1.5')
  y <- dbGetQueryArrow(con, 'SELECT * FROM iris WHERE "Petal.Width" < 0.2')
  list(sepal = list(length = a, width = b), petal = list(length = x, width = y))
})
call_mirai(m)$data
```

As before, `everywhere()` can be used again to cleanly tear down the databases, before resetting daemons.
```{r arrow4}
everywhere(dbDisconnect(con))
daemons(0)
```
