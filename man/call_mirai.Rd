% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mirai.R
\name{call_mirai}
\alias{call_mirai}
\alias{call_mirai_}
\title{mirai (Call Value)}
\usage{
call_mirai(aio)

call_mirai_(aio)
}
\arguments{
\item{aio}{a 'mirai' object.}
}
\value{
The passed mirai (invisibly). The retrieved value is stored at
    \code{$data}.
}
\description{
\code{call_mirai} retrieves the value of a mirai, waiting for the the
    asynchronous operation to resolve if it is still in progress.

\code{call_mirai_} is a variant that allows user interrupts, suitable for
    interactive use.
}
\details{
This function will wait for the async operation to complete if still
    in progress (blocking).

    If an error occurs in evaluation, the error message is returned as a
    character string of class 'miraiError' and 'errorValue'.
    \code{\link{is_mirai_error}} may be used to test for this.

    \code{\link{is_error_value}} tests for all error conditions including
    mirai errors, interrupts, and timeouts.

    The mirai updates itself in place, so to access the value of a mirai
    \code{x} directly, use \code{call_mirai(x)$data}.
}
\section{Alternatively}{


    The value of a mirai may be accessed at any time at \code{$data}, and
    if yet to resolve, an 'unresolved' logical NA will be returned instead.

    Using \code{\link{unresolved}} on a mirai returns TRUE only if a mirai
    has yet to resolve and FALSE otherwise. This is suitable for use in
    control flow statements such as \code{while} or \code{if}.
}

\examples{
if (interactive()) {
# Only run examples in interactive R sessions

# using call_mirai()
df1 <- data.frame(a = 1, b = 2)
df2 <- data.frame(a = 3, b = 1)
m <- mirai(as.matrix(rbind(df1, df2)), .args = list(df1, df2), .timeout = 1000)
call_mirai(m)$data

# using unresolved()
m <- mirai({
  res <- rnorm(n)
  res / rev(res)
  },
  n = 1e6)
while (unresolved(m)) {
  cat("unresolved\n")
  Sys.sleep(0.1)
}
str(m$data)

}

}
